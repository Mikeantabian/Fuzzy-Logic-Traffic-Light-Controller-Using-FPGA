# Fuzzy Logic VHDL Modules

This repository contains a suite of reusable VHDL modules designed to implement fuzzy logic systems. These modules are highly configurable and modular, allowing them to handle various fuzzy logic rules and inputs. The repository consists of the following four core modules:

- [Fuzzy_Package](#fuzzy_package)
- [Input Module](#input-module)
- [Output Module](#output-module)
- [Rule Base Module](#rule-base-module)
- [Fuzzy_Controller Module](#fuzzy_controller-module)

---

## Fuzzy_Package

### Overview
The `Fuzzy_Package` contains several essential types, functions, and records that define the basic structure of membership functions, fuzzy rules, and outputs. This package serves as the foundation for the `input`, `output`, and `rule_base` modules.

### Contents
- **MF_structure**: A record that defines the structure of each membership function. Each membership function is represented by:
  - `point1`: The start point of the membership function (usually where the degree is 0).
  - `slope1`: The slope of the increasing part of the membership function.
  - `point2`: The peak point of the membership function (where the membership degree reaches 1).
  - `slope2`: The slope of the decreasing part of the membership function.

- **membership_functions**: An array type that holds multiple membership functions (based on `MF_structure`), allowing dynamic definitions of any number of membership functions.

- **member_outputs**: An array type that holds the fuzzified output values (membership degrees) for each membership function.

- **singletons**: This type represents the crisp singleton values for each membership function, which are used during the defuzzification process.

- **rule_outputs**: This array holds the outputs generated by the evaluation of fuzzy logic rules.

- **integer_array** and **integer_matrix**: These are utility types for representing arrays and matrices of integers, simplifying how rule conditions and input parameters are managed in the other modules.

### Functions
- **Membership_Fuzzification**: 
  This function takes a crisp input and an array of membership functions, computes the degree of membership for each membership function, and returns the fuzzified outputs. The function handles the logic of increasing and decreasing membership slopes based on the crisp input and the membership function's points and slopes.

- **conjunction** and **disjunction**:
  These helper functions compute the minimum (AND) and maximum (OR) of two membership degrees, respectively. They are the fundamental operations for handling fuzzy logic rules.

- **all_AND_rule** and **all_OR_rule**:
  These functions handle rules that apply AND (conjunction) or OR (disjunction) operations to multiple membership degrees. They loop over the input membership degrees and apply the corresponding operation.

- **mixed_AND_OR_rule**:
  This function handles mixed rules where two sets of inputs are combined using both AND and OR operations, such as `(A AND B) OR (C AND D)`.

- **Defuzzification**:
  This function uses the centroid (center of gravity) method to convert fuzzy outputs into a single crisp value. It takes the weighted sum of the membership degrees and their associated singleton values to compute the final crisp output.

---

## Input Module

### Overview
The `input` module is responsible for fuzzifying a crisp input value into fuzzy membership degrees. This module is highly dynamic, as it can handle any number of membership functions by passing arrays of points and slopes. This dynamic nature makes it highly reusable across different fuzzy logic systems.

### Ports
- **crisp_input** (`in std_logic_vector(7 downto 0)`): The crisp input value to be fuzzified.
- **reset** (`in std_logic`): A reset signal (currently unused in this module but included for future expandability).
- **mf_point1_array** (`in integer_array(0 to mf_num-1)`): An array of starting points for each membership function.
- **mf_point2_array** (`in integer_array(0 to mf_num-1)`): An array of peak points for each membership function.
- **mf_slope1_array** (`in integer_array(0 to mf_num-1)`): An array of slopes for the increasing parts of each membership function.
- **mf_slope2_array** (`in integer_array(0 to mf_num-1)`): An array of slopes for the decreasing parts of each membership function.
- **membership_degrees** (`out member_outputs(0 to mf_num-1)`): The fuzzified membership degrees, which represent the degree of membership of the input value for each membership function.

### How It Works
The `input` module is driven by a process that:
1. Loops over each membership function (defined by `mf_num`), assigns the corresponding points and slopes to the membership function structure.
2. Calls the `Membership_Fuzzification` function from the `Fuzzy_Package`, passing the crisp input and the configured membership functions.
3. The `Membership_Fuzzification` function calculates the degree of membership for each function and returns the fuzzy outputs.
4. These fuzzy outputs are assigned to the `membership_degrees` output, which is then passed to the rule base for further processing.

### Key Features
- **Dynamic Configuration**: The module dynamically assigns points and slopes to each membership function, making it highly reusable and adaptable to systems with varying numbers of membership functions.
- **Automatic Fuzzification**: By calling the `Membership_Fuzzification` function, the module automatically computes the fuzzy degrees based on the crisp input and the membership functions' parameters.

---

## Output Module

### Overview
The `output` module is responsible for converting the fuzzy membership degrees generated by the rule base into a crisp output value. It uses the centroid (center of gravity) method, which calculates the weighted average of the fuzzy degrees and their associated singleton values.

### Ports
- **output_mf_values** (`in rule_outputs(0 to output_num-1)`): The fuzzy membership values from the rule base.
- **singleton_values** (`in singletons(0 to output_num-1)`): The singleton values that correspond to the membership functions.
- **crisp_output** (`out std_logic_vector(7 downto 0)`): The final crisp output value after defuzzification.

### How It Works
The `output` module works by:
1. Receiving the fuzzy membership function values from the rule base and their associated singleton values.
2. Passing these values to the `Defuzzification` function in the `Fuzzy_Package`, which calculates the crisp output using the centroid method.
3. The result is assigned to the `crisp_output` port, which can then be used by external systems or peripherals.

### Defuzzification Process
The centroid method used in the `Defuzzification` function works by:
- Calculating the weighted sum of the fuzzy membership degrees and their corresponding singleton values.
- Dividing the weighted sum by the total sum of the membership degrees.
- This produces a single crisp value that represents the most appropriate output for the given fuzzy inputs.

### Key Features
- **Simple and Effective**: The `output` module is straightforward, with only one function call to defuzzify the fuzzy outputs.
- **Reusable**: Like the `input` module, the `output` module is highly reusable and can be applied to any fuzzy logic system where a crisp output needs to be generated.

---

## Rule Base Module

### Overview
The `rule_base` module is the most complex and critical component of the fuzzy logic system. It handles the evaluation of fuzzy logic rules, which are defined by conditions on the input membership degrees. The module supports a variety of rule types, including AND, OR, and mixed rules, and it aggregates the results into combined outputs for further processing.

### Ports
- **rule_type_array** (`in integer_array(0 to rule_num-1)`): Specifies the type of each rule, where 0 indicates an AND rule and 1 indicates an OR rule.
- **rule_conditions_array** (`in integer_matrix(0 to rule_num-1, 0 to input_num-1)`): Defines the conditions for each rule. Each entry in the matrix specifies whether the corresponding input membership degree is involved in the rule (1 for included, 0 for excluded).
- **output_notation** (`in integer_array(0 to rule_num-1)`): Maps each rule to a specific output membership function.
- **reset** (`in std_logic`): A reset signal that clears the outputs.
- **membership_degrees** (`in member_outputs(0 to input_num-1)`): The input membership degrees from the fuzzification process.
- **rule_output** (`out rule_outputs(0 to rule_num-1)`): The outputs generated by evaluating the rules.
- **combined_outputs** (`out rule_outputs(0 to final_num-1)`): The aggregated outputs, where rules that share the same output membership function are combined using disjunction (OR).

### How It Works
The `rule_base` module is divided into two main processes:
1. **Rule Evaluation**: 
   - The module loops through each rule defined in the `rule_type_array`. For each rule, it initializes a result based on the rule type (either AND or OR).
   - It then loops through the input membership degrees, checking which degrees are involved in the rule (as defined by the `rule_conditions_array`).
   - Depending on the rule type, it applies either conjunction (AND) or disjunction (OR) to the involved membership degrees.
   - The result for each rule is stored in the `rule_output` signal.

2. **Output Aggregation**:
   - The second process aggregates the outputs for rules that share the same output membership function. This is done by looping through the `output_notation` array and applying disjunction to combine the results of rules that map to the same output.
   - The combined results are stored in the `combined_outputs` signal.

### Rule Evaluation Logic
- **AND Rules**: For AND rules (specified by `rule_type_array` = 0), the module initializes the result to the maximum value (`x"FF"`) and applies conjunction to the relevant membership degrees. This ensures that the result is the minimum of the degrees involved in the rule, as required by fuzzy AND logic.
- **OR Rules**: For OR rules (specified by `rule_type_array` = 1), the module initializes the result to the minimum value (`x"00"`) and applies disjunction to the relevant membership degrees. This ensures that the result is the maximum of the degrees involved in the rule, as required by fuzzy OR logic.
- **Mixed Rules**: The `mixed_AND_OR_rule` function handles more complex rules that involve both AND and OR operations, such as `(A AND B) OR (C AND D)`.

### Key Features
- **Highly Configurable**: The rule base can handle any number of rules and inputs, thanks to the use of arrays and matrices. Each rule can be defined independently, and the module can handle different types of rules (AND, OR, and mixed).
- **Dynamic Aggregation**: The `combined_outputs` port aggregates the results of rules that share the same output membership function, ensuring that the final outputs reflect all relevant rules.
- **Efficient Logic**: The rule base efficiently processes the rules in parallel, ensuring that the system can handle complex fuzzy logic rules without performance bottlenecks.

### Example Rule Evaluation
Consider a system with three inputs and three rules:
1. Rule 1: `(input1 AND input2)` → Low output.
2. Rule 2: `(input1 OR input3)` → Medium output.
3. Rule 3: `(input2 AND input3)` → High output.

In this case, the `rule_type_array` would contain `[0, 1, 0]` (AND, OR, AND), the `rule_conditions_array` would specify which inputs are involved in each rule, and the `output_notation` would map each rule to its respective output (Low, Medium, or High). The module would then evaluate each rule, combine the outputs where necessary, and produce the final aggregated results in `combined_outputs`.


## Fuzzy_Controller Module

### Overview
The `Fuzzy_Controller` module is a simplified, generic example template that serves as a foundation for implementing fuzzy logic in various projects. It includes only one input, one rule base, and one output, which makes it easy to modify and expand for specific use cases. The module applies fuzzification to a single input signal, evaluates a set of predefined fuzzy rules, and outputs a crisp value through defuzzification. This basic structure can be adapted to suit more complex systems by adding more inputs, membership functions, or rules as needed.

### How It Works
- **Input Fuzzification**: The `Fuzzy_Controller` uses the `input` module to fuzzify a crisp input signal based on two predefined membership functions. The membership functions are defined by points and slopes that determine how the input is classified into fuzzy terms (e.g., Low, Medium, High).
  
- **Rule Base Evaluation**: The `rule_base` module evaluates the fuzzified input values according to a set of four predefined rules. Each rule operates on the membership degrees, applying either AND or OR logic to generate fuzzy output values.

- **Defuzzification**: Finally, the `output` module converts the fuzzy output values into a crisp value using singleton values that represent predefined crisp outputs for each fuzzy term.

### Key Features
- **Highly Editable**: This module is designed to be easily modified for any fuzzy logic project. The number of membership functions, rules, and outputs can be adjusted by changing the generic parameters and signal definitions. The structure remains the same, allowing for the reuse of code across multiple projects with different fuzzy logic requirements.

- **Template for Customization**: This controller acts as a starting point for developers looking to implement fuzzy logic in their projects. You can add additional inputs (e.g., temperature, speed, etc.), more complex rule sets, or different output types (e.g., PWM signals) by simply expanding the membership functions, rule base, and output mapping.

### Example Use Cases
- **Basic Control Systems**: The `Fuzzy_Controller` is perfect for simple control systems that need to respond to a single input and output a value based on fuzzy rules. For instance, it could be used in basic tipping, temperature control, or fan speed control projects.
  
- **Expandability**: For more complex projects, additional inputs and rules can be added with minimal changes. For instance, this template could easily be adapted to handle multiple inputs like temperature and humidity for controlling an HVAC system.

### Customization Guide
- To **add more inputs**, simply add another `input` module and adjust the `input_num` and `rule_conditions_array` accordingly.
- To **modify the rules**, edit the `rule_type_array` and `rule_conditions_array` to fit your specific fuzzy logic needs.
- To **change the output behavior**, modify the `singleton_values` array to reflect different crisp output values for each fuzzy term.

This module provides the basic building blocks for fuzzy logic and allows developers to quickly implement and customize fuzzy logic systems for unique applications.

